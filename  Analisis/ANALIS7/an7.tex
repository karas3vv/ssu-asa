\documentclass[otchet]{SCWorks}
% Тип обучения (одно из значений):
%    bachelor   - бакалавриат (по умолчанию)
%    spec       - специальность
%    master     - магистратура
% Форма обучения (одно из значений):
%    och        - очное (по умолчанию)
%    zaoch      - заочное
% Тип работы (одно из значений):
%    coursework - курсовая работа (по умолчанию)
%    referat    - реферат
%  * otchet     - универсальный отчет
%  * nirjournal - журнал НИР
%  * digital    - итоговая работа для цифровой кафедры
%    diploma    - дипломная работа
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу

% * Добавлены вручную. За вопросами к @mchernigin
\usepackage{preamble}

\begin{document}

% Кафедра (в родительном падеже)
\chair{информатики и программирования}

% Тема работы
\title{Анализ алгоритма Бойера-Мура}
% Курс
\course{2}

% Группа
\group{251}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
% \department{факультета КНиИТ}

% Специальность/направление код - наименование
% \napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
% \napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
% \napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
% \napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
% \studenttitle{студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Карасева Вадима Дмитриевича}

% Заведующий кафедрой
\chtitle{доцент, к.\,ф.-м.\,н.}
\chname{С.\,В.\,Миронов}

% Руководитель ДПП ПП для цифровой кафедры (перекрывает заведующего кафедры)
% \chpretitle{
%     заведующий кафедрой математических основ информатики и олимпиадного\\
%     программирования на базе МАОУ <<Ф"=Т лицей №1>>
% }
% \chtitle{г. Саратов, к.\,ф.-м.\,н., доцент}
% \chname{Кондратова\, Ю.\,Н.}

% Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{М.\,И.\,Сафрончик}

% Руководитель практики от организации (руководитель для цифровой кафедры)
\patitle{доцент, к.\,ф.-м.\,н.}
\paname{С.\,В.\,Миронов}

% Руководитель НИР
\nirtitle{доцент, к.\,п.\,н.} % степень, звание
\nirname{В.\,А.\,Векслер}

% Семестр (только для практики, для остальных типов работ не используется)
\term{2}

% Наименование практики (только для практики, для остальных типов работ не
% используется)
\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики, для
% остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных типов
% работ не используется)
\practStart{01.07.2024}
\practFinish{13.01.2024}

% Год выполнения отчета
\date{2025}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам (по умолчанию -
% нумерация сквозная) (допускается оба вида нумерации)
\secNumbering

\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
% \abbreviations
% \begin{description}
%     \item ... "--- ...
%     \item ... "--- ...
% \end{description}

% Раздел "Определения". Может отсутствовать в работе
% \definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и
% "Определения"
% \defabbr

% \intro

% После введения — серии \section, \subsection и т.д.

\section{Пример программы}
\begin{minted}[fontsize=\small, breaklines=true, style=bw, linenos, highlightlines={}]{cpp}
#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>

using namespace std;

// Функция для создания таблицы "плохого символа"
vector<int> buildBadCharTable(const string& pattern) {
    const int ALPHABET_SIZE = 256;
    vector<int> badCharTable(ALPHABET_SIZE, -1);

    for (int i = 0; i < pattern.size(); i++) {
        badCharTable[(unsigned char)pattern[i]] = i;
    }

    return badCharTable;
}

// Алгоритм Бойера - Мура (только эвристика плохого символа)
vector<int> boyerMooreSearch(const string& text, const string& pattern) {
    vector<int> result;
    int n = text.size();
    int m = pattern.size();

    if (m == 0 || n < m) return result;

    vector<int> badChar = buildBadCharTable(pattern);

    int shift = 0;

    while (shift <= (n - m)) {
        int j = m - 1;

        // Сравнение с конца шаблона
        while (j >= 0 && pattern[j] == text[shift + j]) {
            j--;
        }

        // Если шаблон найден
        if (j < 0) {
            result.push_back(shift);
            shift += (shift + m < n) ? m - badChar[(unsigned char)text[shift + m]] : 1;
        } else {
            // Смещение по эвристике плохого символа
            shift += max(1, j - badChar[(unsigned char)text[shift + j]]);
        }
    }

    return result;
}

int main() {
    string text, pattern;

    cout << "Введите текст для поиска: ";
    getline(cin, text);

    cout << "Введите шаблон для поиска: ";
    getline(cin, pattern); 

    vector<int> matches = boyerMooreSearch(text, pattern);  // выполняем поиск

    if (matches.empty()) {  // если совпадений нет
        cout << "Шаблон не найден в тексте." << endl;
    } else {  // если совпадения есть
        cout << "Найденные позиции: ";  
        for (int pos : matches) {  
            cout << pos << " ";  
        }
        cout << endl;
    }

    return 0; 
}
\end{minted}

\section{Анализ сложности}
Внутри основного цикла может быть выполнено не более $\frac{n}{m}$ сдвигов (каждый сдвиг хотя бы на одну позицию).
Кроме того, при каждом сдвиге мы можем использовать информацию из таблицы "плохих символов"для определения дополнительного сдвига. 
- В худшем случае для каждого сдвига может потребоваться $O(m)$ времени, чтобы определить этот сдвиг.
Таким образом, временная сложность алгоритма Бойера-Мура в худшем случае составляет:


$O(m) + O(n) * O(m) = O(nm)$

Исходный текст: $bb…bb$

Шаблон: $abab…abab$

Из-за того, что все символы b из текста повторяются в шаблоне $m/2$ раз, эвристика хорошего символа будет пытаться сопоставить шаблон в каждой позиции (суммарно, n раз), 
а эвристика плохого символа в каждой позиции будет двигать строку $m/2$ раз. Итого, $O(n*m)$

где $n$ — длина исходного текста, $n$ — длина шаблона, $m$ — размер алфавита.

Это означает, что в худшем случае алгоритм будет выполняться за время, пропорциональное произведению длины текста на длину шаблона.

В лучшем случае алгоритм использует преимущества таблицы "плохих символов" для значительных сдвигов, что уменьшает количество сравнений и сдвигов: При каждом сдвиге шаблон смещается на значительное расстояние, m позиций сразу, если символ, следующий за совпадением, отсутствует в шаблоне. Количество сдвигов ограничено  $\frac{n}{m}$. 
В лучшем случае:

$O(m) + O(\frac{n}{m}) * O(m) = O(m) + O(n) = O(n)$

Лучший случай:

Исходный текст: $abracadabra$

Шаблон: $hhhh$

В таком случае будет временная сложность будет равняться $O(m) + O(\frac{n}{m}) = O(\frac{n}{m})$.

$O(n)$ - длина исходной строки.

$\frac{n}{m}$ - количество сдвигов шаблона по тексту. $O(m)$ - время на проверку символов шаблона на каждой позиции, но в лучшем случае это практически всегда константное время, так как шаблон сразу сдвигается на m позиций.

% Отобразить все источники. Даже те, на которые нет ссылок.
% \nocite{*}

% \begin{thebibliography}{99}
	\bibliographystyle{ugost2003}

% \end{thebibliography}

% Окончание основного документа и начало приложений Каждая последующая секция
% документа будет являться приложением
\appendix

\end{document}
\documentclass[otchet]{SCWorks}
% Тип обучения (одно из значений):
%    bachelor   - бакалавриат (по умолчанию)
%    spec       - специальность
%    master     - магистратура
% Форма обучения (одно из значений):
%    och        - очное (по умолчанию)
%    zaoch      - заочное
% Тип работы (одно из значений):
%    coursework - курсовая работа (по умолчанию)
%    referat    - реферат
%  * otchet     - универсальный отчет
%  * nirjournal - журнал НИР
%  * digital    - итоговая работа для цифровой кафедры
%    diploma    - дипломная работа
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу

% * Добавлены вручную. За вопросами к @mchernigin
\usepackage{preamble}

\begin{document}

% Кафедра (в родительном падеже)
\chair{информатики и программирования}

% Тема работы
\title{Анализ сложности сортировок, не использующих сравнение элементов}

% Курс
\course{2}

% Группа
\group{251}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
% \department{факультета КНиИТ}

% Специальность/направление код - наименование
% \napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
% \napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
% \napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
% \napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
% \studenttitle{студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Карасева Вадима Дмитриевича}

% Заведующий кафедрой
\chtitle{доцент, к.\,ф.-м.\,н.}
\chname{С.\,В.\,Миронов}

% Руководитель ДПП ПП для цифровой кафедры (перекрывает заведующего кафедры)
% \chpretitle{
%     заведующий кафедрой математических основ информатики и олимпиадного\\
%     программирования на базе МАОУ <<Ф"=Т лицей №1>>
% }
% \chtitle{г. Саратов, к.\,ф.-м.\,н., доцент}
% \chname{Кондратова\, Ю.\,Н.}

% Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{М.\,И.\,Сафрончик}

% Руководитель практики от организации (руководитель для цифровой кафедры)
\patitle{доцент, к.\,ф.-м.\,н.}
\paname{С.\,В.\,Миронов}

% Руководитель НИР
\nirtitle{доцент, к.\,п.\,н.} % степень, звание
\nirname{В.\,А.\,Векслер}

% Семестр (только для практики, для остальных типов работ не используется)
\term{2}

% Наименование практики (только для практики, для остальных типов работ не
% используется)
\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики, для
% остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных типов
% работ не используется)
\practStart{01.07.2024}
\practFinish{13.01.2024}

% Год выполнения отчета
\date{2025}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам (по умолчанию -
% нумерация сквозная) (допускается оба вида нумерации)
\secNumbering

\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
% \abbreviations
% \begin{description}
%     \item ... "--- ...
%     \item ... "--- ...
% \end{description}

% Раздел "Определения". Может отсутствовать в работе
% \definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и
% "Определения"
% \defabbr

% \intro

% После введения — серии \section, \subsection и т.д.

\section{Сортировки}
\subsection{Сортировка подсчетом}
\begin{minted}{cpp}
    vector<int> arr(n); 
    int max_value = INT_MIN; // инициализируем минимально 
	// возможное значение
    int min_value = INT_MAX; // инициализируем максимально 
	// возможное значение

    // вводим элементы и находим min и max значения
    for (int i = 0; i < n; i++) {
        cout << i + 1 << ": ";
        cin >> arr[i];
        max_value = max(max_value, arr[i]); // обновляем максимум
        min_value = min(min_value, arr[i]); // обновляем минимум
    }

    // создаем массив для подсчета, размером от min до max значения
    vector<int> count_arr(max_value - min_value + 1, 0);

    // подсчитываем количество каждого элемента
    for (int i : arr) {
        count_arr[i - min_value]++; // увеличиваем счетчик для 
		// текущего числа
    }

    // восстанавливаем отсортированный массив из счетчиков
    int j = 0; // индекс для заполнения исходного массива
    for (int i = 0; i < count_arr.size(); i++) {
        while (count_arr[i] > 0) {
            arr[j++] = i + min_value; // записываем число 
			// обратно в массив
            count_arr[i]--; // уменьшаем счетчик
        }
    }
\end{minted}

\subsection{Поразрядная сортировка (LSD)}
\begin{minted}{cpp}
// функция для определения максимального кол-ва 
// разрядов в числах вектора
int k(vector<int>& vec) {
    int retK = 0; // переменная для хранения максимального 
	// кол-ва разрядов
    
    // перебираем все числа в векторе
    for (int n : vec) {
        int cnt; // счетчик разрядов текущего числа
        
        // особый случай для числа 0 (у него 1 разряд)
        if (n == 0){
            cnt = 1;
        } else {
            cnt = 0;
        }
        
        // считаем кол-во разрядов в числе
        while (n != 0) {
            n /= 10; // удаляем младший разряд
            cnt++;
        }
        
        // обновляем максимальное кол-во разрядов, 
		// если текущее число имеет больше разрядов
        if (cnt > retK) {
            retK = cnt;
        }
    }
    return retK;
}

// функция поразрядной сортировки (LSD - Least Significant Digit)
void radixSort(std::vector<int>& vec) {
    int dig = k(vec); // получаем максимальное кол-во разрядов
    vector<vector<int> > p(10); // вектор векторов для цифр от 0 до 9
    
    // проходим по всем разрядам, начиная с младшего
    for (int i = 0; i < dig; i++) {
        // распределяем числа по корзинам в 
		// соответствии с текущей цифрой
        for (int j = 0; j < vec.size(); j++) {
            // вычисляем текущую цифру (i-й разряд числа)
            int dig_cnt = (abs(vec[j]) / static_cast<int>(pow(10,i)) % 10);
            p[dig_cnt].push_back(vec[j]); // помещаем число в 
			// соответствующую корзину
        }
        
        // собираем числа из корзин обратно в исходный вектор
        int ind = 0; // индекс для вставки в исходный вектор
        for (int i = 0; i < 10; i++) {
            for (int n : p[i]) {
                vec[ind++] = n; // последовательно берем 
				// числа из всех корзин
            }
            p[i].clear(); // очищаем корзину для следующего разряда
        }
    }
}
\end{minted}

\section{Анализ сложности сортировок}
\subsection{Сортировка подсчетом}
Функция нахождения \texttt{max\_value} и \texttt{min\_value} выполняется за время $O(n)$, где $n$ — размер исходного массива, так как в одном цикле происходит и ввод, и поиск минимума и максимума.

Вычисление размера счётного массива $(\texttt{max\_value} - \texttt{min\_value} + 1)$ и передача его в \texttt{vector<int> count\_arr(...)} происходит за время $O(1)$.

Инициализация массива \texttt{count\_arr} размером $k = \texttt{max\_value} - \texttt{min\_value} + 1$ выполняется за время $O(k)$, где $k$ — диапазон возможных значений элементов массива.

Массив \texttt{arr} уже был создан ранее, поэтому дополнительных затрат на его инициализацию не происходит. Однако логически восстановление отсортированного массива эквивалентно созданию нового, что учитывается как $O(n)$.

Первый цикл, отвечающий за подсчёт частот элементов в \texttt{count\_arr}, выполняется за время $O(n)$, так как каждый элемент массива \texttt{arr} обрабатывается один раз.

В данной реализации \textbf{отсутствует этап построения префиксной суммы}, но если бы он был, его сложность составила бы $O(k)$. Однако, в текущем коде сразу восстанавливается отсортированный массив из счётчиков, без вычисления префиксной суммы.

Второй цикл (восстановление массива) проходит по \texttt{count\_arr}, и каждый элемент записывается столько раз, сколько он встречался. Общее количество операций записи в \texttt{arr} равно $n$. Таким образом, цикл работает за $O(n + k)$: $k$ — длина \texttt{count\_arr}, $n$ — количество итераций в общей сумме \texttt{while}-циклов.

\textbf{Итог:}
\begin{itemize}
    \item $n$ — количество элементов в исходном массиве.
    \item $k$ — диапазон значений $(\texttt{max\_value} - \texttt{min\_value} + 1)$.
    \item \textbf{Общая сложность:} $O(n + k)$.
\end{itemize}

\subsection{Поразрядная сортировка (LSD)}
Функция \texttt{k(vec)}, определяющая максимальное количество разрядов в числах вектора, выполняется за время $O(n \cdot d)$, где $n$ — размер исходного массива, а $d$ — максимальное количество разрядов в числе (в худшем случае $d = \log_{10}(\text{max})$).

Вычисление параметров, включая создание массива корзин (вектор из 10 векторов), происходит за время $O(1)$.

Каждая итерация внешнего цикла, проходящего по всем разрядам (от младшего к старшему), выполняется $d$ раз, где $d$ — количество разрядов.

Во внутреннем цикле каждое число помещается в соответствующую корзину, что осуществляется за $O(n)$ на каждой итерации.

Сборка чисел из корзин обратно в исходный массив также осуществляется за $O(n)$ на каждой итерации.

Очистка всех корзин за одну итерацию выполняется за $O(n)$, так как в сумме через корзины проходит $n$ элементов.

Таким образом, каждый проход по одному разряду выполняется за $O(n)$, а таких проходов $d$, следовательно, общая временная сложность составляет (согласно правилу суммы):

\[
O(n \cdot d) + O(1) + O(n \cdot d) + O(n \cdot d) + O(n \cdot d) = O(n \cdot d)
\]

\textbf{Итог:}
\begin{itemize}
    \item $n$ — количество элементов в массиве.
    \item $d$ — количество разрядов (в десятичной системе — $d = \lfloor \log_{10}(\text{max}) \rfloor + 1$).
    \item \textbf{Общая временная сложность:} $O(n \cdot d)$.
\end{itemize}
% Отобразить все источники. Даже те, на которые нет ссылок.
% \nocite{*}

% \begin{thebibliography}{99}
	\bibliographystyle{ugost2003}

% \end{thebibliography}

% Окончание основного документа и начало приложений Каждая последующая секция
% документа будет являться приложением
\appendix

\end{document}

\documentclass[otchet]{SCWorks}
% Тип обучения (одно из значений):
%    bachelor   - бакалавриат (по умолчанию)
%    spec       - специальность
%    master     - магистратура
% Форма обучения (одно из значений):
%    och        - очное (по умолчанию)
%    zaoch      - заочное
% Тип работы (одно из значений):
%    coursework - курсовая работа (по умолчанию)
%    referat    - реферат
%  * otchet     - универсальный отчет
%  * nirjournal - журнал НИР
%  * digital    - итоговая работа для цифровой кафедры
%    diploma    - дипломная работа
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу

% * Добавлены вручную. За вопросами к @mchernigin
\usepackage{preamble}

\begin{document}

% Кафедра (в родительном падеже)
\chair{информатики и программирования}

% Тема работы
\title{Анализ сложности быстрой и пирамидальной сортировок}

% Курс
\course{2}

% Группа
\group{251}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
% \department{факультета КНиИТ}

% Специальность/направление код - наименование
% \napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
% \napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
% \napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
% \napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
% \studenttitle{студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Карасева Вадима Дмитриевича}

% Заведующий кафедрой
\chtitle{доцент, к.\,ф.-м.\,н.}
\chname{С.\,В.\,Миронов}

% Руководитель ДПП ПП для цифровой кафедры (перекрывает заведующего кафедры)
% \chpretitle{
%     заведующий кафедрой математических основ информатики и олимпиадного\\
%     программирования на базе МАОУ <<Ф"=Т лицей №1>>
% }
% \chtitle{г. Саратов, к.\,ф.-м.\,н., доцент}
% \chname{Кондратова\, Ю.\,Н.}

% Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{М.\,И.\,Сафрончик}

% Руководитель практики от организации (руководитель для цифровой кафедры)
\patitle{доцент, к.\,ф.-м.\,н.}
\paname{С.\,В.\,Миронов}

% Руководитель НИР
\nirtitle{доцент, к.\,п.\,н.} % степень, звание
\nirname{В.\,А.\,Векслер}

% Семестр (только для практики, для остальных типов работ не используется)
\term{2}

% Наименование практики (только для практики, для остальных типов работ не
% используется)
\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики, для
% остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных типов
% работ не используется)
\practStart{01.07.2024}
\practFinish{13.01.2024}

% Год выполнения отчета
\date{2025}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам (по умолчанию -
% нумерация сквозная) (допускается оба вида нумерации)
\secNumbering

\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
% \abbreviations
% \begin{description}
%     \item ... "--- ...
%     \item ... "--- ...
% \end{description}

% Раздел "Определения". Может отсутствовать в работе
% \definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и
% "Определения"
% \defabbr

% \intro

% После введения — серии \section, \subsection и т.д.

\section{Сортировки}
\subsection{Быстрая сортировка}
\begin{minted}{cpp}
void quickSort(std::vector<int>& arr, int left, int right) {
    // Базовый случай: если подмассив содержит 0 или 1 элемент
    if (left >= right) return; // O(1)

    // 1. Выбор опорного элемента (pivot)
    int pivot = arr[(left + right) / 2]; // O(1) - средний элемент
    // Можно выбрать первый, последний или случайный элемент

    // 2. Разделение (partition)
    int i = left; // O(1)
    int j = right; // O(1)

    while (i <= j) { // O(kn), n - количество элементов, k - количество повторений внешнего цикла
        // Ищем элемент больше опорного слева
        while (arr[i] < pivot) i++; // O(t), t – количество элементов до опорного

        // Ищем элемент меньше опорного справа
        while (arr[j] > pivot) j--; // O(m)

        // Если индексы не пересеклись, меняем элементы местами
        if (i <= j) { // O(t + m) = O(n)
            std::swap(arr[i], arr[j]); // O(1)
            i++; // O(1)
            j--; // O(1)
        }
    }

    // 3. Рекурсивные вызовы для подмассивов
    quickSort(arr, left, j); // O(log n)
    quickSort(arr, i, right); // O(log n)
}
\end{minted}

\subsection{Пирамедальная сортировка}
\begin{minted}{cpp}
void heap(vector<int>& c, int i, int n) { // сложность o(log n)
    // предполагаем, что текущий элемент - максимальный
    int ind_mx = i;
    // проверяем левого потомка
    if (i * 2 + 1 < n) {
        // если левый потомок больше текущего максимума
        if (c[ind_mx] < c[i * 2 + 1])
            ind_mx = i * 2 + 1;
    }
    // проверяем правого потомка
    if (i * 2 + 2 < n) {
        // если правый потомок больше текущего максимума
        if (c[ind_mx] < c[i * 2 + 2])
            ind_mx = i * 2 + 2;
    }
    // если максимум изменился
    if (ind_mx != i) {
        // меняем местами текущий элемент с максимальным потомком
        swap(c[i], c[ind_mx]);
        // рекурсивно вызываем heap для поддерева
        heap(c, ind_mx, n);
    }
}

// функция пирамидальной сортировки (heapsort)
void pyramid_sort(vector<int>& c, int n) {
    // построение max-heap (начиная с последнего нелистового узла)
    for (int i = n / 2 - 1; i >= 0; i--) // сложность o(n)
        heap(c, i, n); // сложность o(log n)

    // извлечение элементов из кучи по одному
    for (int i = n - 1; i >= 0; i--) { // сложность o(n)
        // перемещаем текущий корень в конец
        swap(c[0], c[i]); // сложность o(1)
        // восстанавливаем max-heap для уменьшенной кучи
        heap(c, 0, i); // сложность o(log n)
    }
}
\end{minted}

\section{Анализ сложности сортировок}
\subsection{Быстрая сортировка}

Общая сложность: 

Для 2-х вложенных циклов общая сложность равна: $(t + m)$ = O($n$), Для внешнего
$while$ сложность: O($k_n$), где $n$ – общее кол-во элементов, $k$ – кол-во повторений
внешнего цикла. Тогда общая сложность по правилу суммы: O(max($k_n$,1,1)) = O($k_n$).


Если массив отсортирован, то в лучшем случае мы просто пройдёмся по его
n элементам. Сложность равна O($n \log n$), так как мы делим каждый раз при
рекурсивном вызове массив пополам, и всего таких случаев $log_2 n$.

Согласно первой теореме:

\[
T(n) = 
\begin{cases}
c, & \text{если } n = 1, \\
1\alpha t \left(\dfrac{n}{k}\right) + bn^\tau, & \text{если } n > 1.
\end{cases}
\]

Построим реккурентное соотношение:
$$
T(n) = 
\begin{cases} 
c, & \text{если } n = 1, \\
2T\left(\frac{n}{2}\right) + bn, & \text{если } n > 1.
\end{cases}
$$

\textbf{Общий случай (лучший/средний)}

Параметры рекурсии:

--- $a = 2$ — количество подзадач,
    
--- $n/k$ — размер подзадачи ($k = 2$ — постоянная),
    
--- Трудоёмкость рекурсивного перехода: $O(n)$, $\tau = 1$.

По следствию основной теоремы для лучшего случая:
\[
t(n) = O(n^\tau \log_k n) = O(n \log n)
\]

\textbf{Худший случай}

Если опорный элемент каждый раз оказывается минимальным или максимальным, происходит неравномерное разделение:

    
--- Один подмассив пуст,
    
--- Другой содержит $n - 1$ элементов.

Для отсортированного массива (прямо или обратно):

    
--- Глубина рекурсии: $n$ уровней,
    
--- На каждом уровне: $O(n)$ операций.


Итоговая сложность:
\[
t(n) = O(n^2)
\]


\subsection{Пирамедальная сортировка}

Алгоритм основан на построении бинарной кучи, которая удовлетворяет следующим свойствам:
\begin{enumerate}
    \item Каждый узел больше своих потомков.
    \item Элементы на последнем уровне располагаются слева направо.
\end{enumerate}

Высота бинарного дерева не превышает $\log_2 N$, поэтому временная сложность функции построения кучи:
$$
T(n) = O(\log n)
$$

Цикл сортировки проходит по всем $n$ элементам, вызывая функцию построения кучи. Таким образом, общая сложность алгоритма:
$$
T(n) = O(n \log n)
$$

Эффективность алгоритма может снижаться, если большие значения находятся в одной части пирамиды.

% Отобразить все источники. Даже те, на которые нет ссылок.
% \nocite{*}

% \begin{thebibliography}{99}
	\bibliographystyle{ugost2003}

% \end{thebibliography}

% Окончание основного документа и начало приложений Каждая последующая секция
% документа будет являться приложением
\appendix

\end{document}

\documentclass[otchet]{SCWorks}
% Тип обучения (одно из значений):
%    bachelor   - бакалавриат (по умолчанию)
%    spec       - специальность
%    master     - магистратура
% Форма обучения (одно из значений):
%    och        - очное (по умолчанию)
%    zaoch      - заочное
% Тип работы (одно из значений):
%    coursework - курсовая работа (по умолчанию)
%    referat    - реферат
%  * otchet     - универсальный отчет
%  * nirjournal - журнал НИР
%  * digital    - итоговая работа для цифровой кафедры
%    diploma    - дипломная работа
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу

% * Добавлены вручную. За вопросами к @mchernigin
\usepackage{preamble}

\begin{document}

% Кафедра (в родительном падеже)
\chair{информатики и программирования}

% Тема работы
\title{Анализ двоичного дерева}

% Курс
\course{2}

% Группа
\group{251}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
% \department{факультета КНиИТ}

% Специальность/направление код - наименование
% \napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
% \napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
% \napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
% \napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
% \studenttitle{студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Карасева Вадима Дмитриевича}

% Заведующий кафедрой
\chtitle{доцент, к.\,ф.-м.\,н.}
\chname{С.\,В.\,Миронов}

% Руководитель ДПП ПП для цифровой кафедры (перекрывает заведующего кафедры)
% \chpretitle{
%     заведующий кафедрой математических основ информатики и олимпиадного\\
%     программирования на базе МАОУ <<Ф"=Т лицей №1>>
% }
% \chtitle{г. Саратов, к.\,ф.-м.\,н., доцент}
% \chname{Кондратова\, Ю.\,Н.}

% Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{М.\,И.\,Сафрончик}

% Руководитель практики от организации (руководитель для цифровой кафедры)
\patitle{доцент, к.\,ф.-м.\,н.}
\paname{С.\,В.\,Миронов}

% Руководитель НИР
\nirtitle{доцент, к.\,п.\,н.} % степень, звание
\nirname{В.\,А.\,Векслер}

% Семестр (только для практики, для остальных типов работ не используется)
\term{2}

% Наименование практики (только для практики, для остальных типов работ не
% используется)
\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики, для
% остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных типов
% работ не используется)
\practStart{01.07.2024}
\practFinish{13.01.2024}

% Год выполнения отчета
\date{2025}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам (по умолчанию -
% нумерация сквозная) (допускается оба вида нумерации)
\secNumbering

\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
% \abbreviations
% \begin{description}
%     \item ... "--- ...
%     \item ... "--- ...
% \end{description}

% Раздел "Определения". Может отсутствовать в работе
% \definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и
% "Определения"
% \defabbr

% \intro

% После введения — серии \section, \subsection и т.д.

\section{Пример программы}
\begin{minted}{cpp}
// Структура узла двоичного дерева поиска
struct Node {
    int key;
    Node* left;
    Node* right;

    Node(int k) : key(k), left(nullptr), right(nullptr) {}
};

// Класс двоичного дерева поиска
class BinarySearchTree {
private:
    Node* root;

    // Рекурсивная функция для добавления узла в дерево
    Node* insertRec(Node* root, int key) {
        if (root == nullptr) {
            return new Node(key);
        }
        if (key < root->key) {
            root->left = insertRec(root->left, key);
        }
        else if (key > root->key) {
            root->right = insertRec(root->right, key);
        }
        return root;
    }

    // Нахождение минимального узла в поддереве
    Node* findMin(Node* node) {
        Node* current = node;
        while (current && current->left != nullptr) {
            current = current->left;
        }
        return current;
    }

    // Рекурсивная функция для удаления узла из дерева
    Node* deleteRec(Node* root, int key) {
        if (root == nullptr) {
            return root;
        }
        if (key < root->key) {
            root->left = deleteRec(root->left, key);
        }
        else if (key > root->key) {
            root->right = deleteRec(root->right, key);
        }
        else {
            if (root->left == nullptr) {
                Node* temp = root->right;
                delete root;
                return temp;
            }
            else if (root->right == nullptr) {
                Node* temp = root->left;
                delete root;
                return temp;
            }
            Node* temp = findMin(root->right);
            root->key = temp->key;
            root->right = deleteRec(root->right, temp->key);
        }
        return root;
    }

    // Рекурсивная функция для поиска узла по ключу
    Node* searchRec(Node* root, int key) {
        if (root == nullptr || root->key == key) {
            return root;
        }
        if (key < root->key) {
            return searchRec(root->left, key);
        }
        return searchRec(root->right, key);
    }

    // Рекурсивная функция для обхода дерева в порядке inorder
    void inorderRec(Node* root) {
        if (root != nullptr) {
            inorderRec(root->left);
            cout << root->key << " ";
            inorderRec(root->right);
        }
    }

    // Рекурсивная функция для обхода дерева в порядке preorder
    void preorderRec(Node* root) {
        if (root != nullptr) {
            cout << root->key << " ";
            preorderRec(root->left);
            preorderRec(root->right);
        }
    }

    // Рекурсивная функция для обхода дерева в порядке postorder
    void postorderRec(Node* root) {
        if (root != nullptr) {
            postorderRec(root->left);
            postorderRec(root->right);
            cout << root->key << " ";
        }
    }

public:
    BinarySearchTree() : root(nullptr) {}

    // Метод для добавления узла в дерево
    void insert(int key) {
        root = insertRec(root, key);
    }

    // Метод для удаления узла из дерева
    void remove(int key) {
        root = deleteRec(root, key);
    }

    // Метод для поиска узла по ключу
    Node* search(int key) {
        return searchRec(root, key);
    }

    // Метод для симметричного обхода дерева
    void inorder() {
        inorderRec(root);
        cout << endl;
    }

    // Метод для прямого обхода дерева
    void preorder() {
        preorderRec(root);
        cout << endl;
    }

    // Метод для обратного обхода дерева
    void postorder() {
        postorderRec(root);
        cout << endl;
    }
};

int main() {
    setlocale(LC_ALL, "RUS");
    srand(time(NULL));

    BinarySearchTree bst;

    int n = 10;
    while (n != 0) {
        int x = rand() % 20;
        if (!bst.search(x)) {
            bst.insert(x);
            n--;
            //cout << x << " ";
        }
    }

    //cout << endl;

    cout << "Симметричный обход: ";
    bst.inorder();

    cout << "Прямой обход: ";
    bst.preorder();

    cout << "Обратный обход: ";
    bst.postorder();

    cout << "Какой ключ хотите удалить?\n";
    int a;
    cin >> a;
    bst.remove(a);
    cout << "Симметричный обход после удаления " << a << " :";
    bst.inorder();

    cout << "Какой ключ хотите найти?\n";
    cin >> a;
    Node* searchResult = bst.search(a);
    if (searchResult) {
        cout << "Узел с ключом " << a << " найден." << endl;
    }
    else {
        cout << "Узел с ключом " << a << " не найден." << endl;
    }

    return 0;
}
\end{minted}

\section{Анализ случаев двоичного дерева}
\subsection{Лучший случай}
Идеально сбалансированное дерево, то есть высота одного поддерева отличается от высоты другого не более чем на 1. Высота такого дерева равна $log_2 N$, где $N$ — количество элементов в дереве.

\subsection{Худший случай}
Дерево не сбалансированное и имеет только одно поддерево. Высота такого дерева будет равна $N$.

\subsection{Средний случай}
Любое другое дерево бинарного поиска. Его высота также составит
$log_2 N$.

\section{Поиск в двоичном дереве}
\subsection{Лучший случай}
Проходим через узлы один за другим. Если мы найдем элемент на втором уровне, то для этого мы сделаем 2 сравнения, если на третьем — 3 сравнения и так далее. Таким образом, на поиск ключа в дереве бинарного поиска мы затратим время, равное высоте дерева, то есть $log_2 N$, поэтому временная сложность  поиска в лучшем случае составит O(logN).

\subsection{Худший случай}
Нужно пройти от корня до самого глубокого узла, являющегося листом, и в этом случае высота дерева становится равной N, где N — количество элементов в дереве, и затрачиваемое время совпадает с высотой дерева. Поэтому временная сложность в худшем случае составит O(N).

\subsection{Средний случай}
Пусть S(N) — среднее значение общей длины внутреннего пути. Докажем, что временная сложность в этом случае составит O(logN).

Очевидно, что для дерева с одним узлом S(1) = 0. Любое бинарное дерево с N узлами содержит i элементов в левом поддереве, 0 $\leq$ i $\leq$ N – 1, а в правом поддереве n - i - 1. Для фиксированного i получим: S(N) = (n - 1) + S(i) + S(n - i - 1), где  (n - 1)  - сумма дополнительных шагов к каждому узлу, учитывая увеличение глубины всех узлов на 1; S(i) – это суммарный внутренний путь в левом поддереве; S(n - i - 1) – это суммарный внутренний путь в правом поддереве. После суммирования этих повторений для 0 $\leq$ i $\leq$ N – 1 получим: $S(n) = n(n-1) + 2\sum\limits_{i=1}^{n-1} S(i)$.

Следовательно, S(N) $\in$ O(NlogN), и глубина узла S(N) $\in$ O(logN).

\section{Вставка в двоичном дереве}
\subsection{Лучший случай}
В идеально сбалансированном дереве нам так же будет необходимо сделать лишь максимум $log_2 N$ сравнений для поиска подходящего места для вставляемого узла, следовательно, временная сложность вставки в лучшем случае составит O(logN).

\subsection{Худший случай}
Нужно пройти от корня до последнего или самого глубокого листового узла, а максимальное количество шагов равно N (высота дерева). Таким образом, временная сложность составит O(N), так как поиск каждого узла один за другим до последнего листового узла займёт время O(N), а затем мы вставим элемент, что занимает константное время.

\subsection{Средний случай}
Проведя рассуждения, аналогичные тем, что были рассмотрены в среднем случае поиска элемента, получаем, что сложность операции вставки в среднем случае составит O(logN).

\section{Удаление в двоичном дереве}
\subsection{Лучший случай}
Снова максимальным значением количества проходов (сравнений) по де- реву будет $log_2 N$ — высота дерева. Копирование содержимого и его удаление требуют константного времени. Поэтому общая временная сложность составит O(logN).

\subsection{Худший случай}
Процесс удаления займёт O(N) времени, так как максимальное количество проходов (сравнений) по дереву равно N .

\subsection{Средний случай}
Проведя рассуждения, аналогичные тем, что были рассмотрены в среднем случае поиска элемента, получаем, что сложность операции удаления в среднем случае составит O(logN).

\section{Обходы дерева}
Дерево бинарного поиска имеет 3 основных обхода: прямой, обратный и симметричный. Их разница заключается в том, в каком порядке мы обращаемся к элементам. Каждый из них будет иметь временную сложность O(N), так как процедура вызывается ровно два раза для каждого узла дерева.

\section{Расход памяти}
В двоичном дереве поиска каждый узел содержит значение и указатели на левого и правого потомков. Расход памяти в двоичном дереве поиска зависит от количества узлов и размера каждого узла.
Предположим, что каждый узел имеет фиксированный размер, состоящий из:

\begin{itemize}
    \item Значения элемента (например, целочисленное значение).
    
    \item Указателя на левого потомка (обычно 4 байта на 32-битной системе или 8 байт на 64-битной системе).
    
    \item Указателя на правого потомка (также 4 или 8 байт).
\end{itemize}

Следовательно, общий размер каждого узла составляет от 12 до 24 байтов в зависимости от архитектуры.

Память, затраченная на двоичное дерево поиска, зависит от количества узлов и их размера. Пусть n - количество узлов в дереве.

Тогда общий расход памяти для дерева будет составлять O(n), так как
каждый узел требует фиксированного количества памяти и количество узлов напрямую пропорционально объему занимаемой памяти.


% Отобразить все источники. Даже те, на которые нет ссылок.
% \nocite{*}

% \begin{thebibliography}{99}
	\bibliographystyle{ugost2003}

% \end{thebibliography}

% Окончание основного документа и начало приложений Каждая последующая секция
% документа будет являться приложением
\appendix

\end{document}

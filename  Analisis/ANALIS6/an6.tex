\documentclass[otchet]{SCWorks}
% Тип обучения (одно из значений):
%    bachelor   - бакалавриат (по умолчанию)
%    spec       - специальность
%    master     - магистратура
% Форма обучения (одно из значений):
%    och        - очное (по умолчанию)
%    zaoch      - заочное
% Тип работы (одно из значений):
%    coursework - курсовая работа (по умолчанию)
%    referat    - реферат
%  * otchet     - универсальный отчет
%  * nirjournal - журнал НИР
%  * digital    - итоговая работа для цифровой кафедры
%    diploma    - дипломная работа
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу

% * Добавлены вручную. За вопросами к @mchernigin
\usepackage{preamble}

\begin{document}

% Кафедра (в родительном падеже)
\chair{информатики и программирования}

% Тема работы
\title{Оценка сложности префикс-функции, Z-функции и алгоритма Кнута-Морриса-Пратта}
% Курс
\course{2}

% Группа
\group{251}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
% \department{факультета КНиИТ}

% Специальность/направление код - наименование
% \napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
% \napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
% \napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
% \napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
% \studenttitle{студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Карасева Вадима Дмитриевича}

% Заведующий кафедрой
\chtitle{доцент, к.\,ф.-м.\,н.}
\chname{С.\,В.\,Миронов}

% Руководитель ДПП ПП для цифровой кафедры (перекрывает заведующего кафедры)
% \chpretitle{
%     заведующий кафедрой математических основ информатики и олимпиадного\\
%     программирования на базе МАОУ <<Ф"=Т лицей №1>>
% }
% \chtitle{г. Саратов, к.\,ф.-м.\,н., доцент}
% \chname{Кондратова\, Ю.\,Н.}

% Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{М.\,И.\,Сафрончик}

% Руководитель практики от организации (руководитель для цифровой кафедры)
\patitle{доцент, к.\,ф.-м.\,н.}
\paname{С.\,В.\,Миронов}

% Руководитель НИР
\nirtitle{доцент, к.\,п.\,н.} % степень, звание
\nirname{В.\,А.\,Векслер}

% Семестр (только для практики, для остальных типов работ не используется)
\term{2}

% Наименование практики (только для практики, для остальных типов работ не
% используется)
\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики, для
% остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных типов
% работ не используется)
\practStart{01.07.2024}
\practFinish{13.01.2024}

% Год выполнения отчета
\date{2025}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам (по умолчанию -
% нумерация сквозная) (допускается оба вида нумерации)
\secNumbering

\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
% \abbreviations
% \begin{description}
%     \item ... "--- ...
%     \item ... "--- ...
% \end{description}

% Раздел "Определения". Может отсутствовать в работе
% \definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и
% "Определения"
% \defabbr

% \intro

% После введения — серии \section, \subsection и т.д.

\section{Префикс-функция}

\begin{minted}[fontsize=\small, breaklines=true, linenos]{cpp}
vector<int> prefix_function(string s) {
    int n = (int) s.size();  // O(1)
    vector<int> p(n, 0);     // О(n)
    for (int i = 1; i < n; i++) {   //O(n)
        int cur = p[i - 1];  // O(1)
        while (s[i] != s[cur] && cur > 0) // О(1) в среднем
            cur = p[cur - 1];  // О(1)
        if (s[i] == s[cur])    // О(1)
            p[i] = cur + 1;    // О(1)
    }
    return p; // О(1)
}
\end{minted}

Инициализация переменной в строке $2$ работает за константу.

Создание вектора в строке $3$ работает за линию.

Далее цикл из строки 4 работает за n. Эта сложность умножается на сумму всех сложностей внутри цикла 4.

В худшем случае цикл $while$ из строки $6$ может работать $O(n)$ раз за одну итерацию, но в среднем каждый $while$ работает за $O(1)$.

Остальные операции внутри внешнего цикла выполняются за константу.
Префикс-функция каждый шаг возрастает максимум на единицу и после каждой итерации $while$ уменьшается хотя бы на единицу. 

Значит, суммарное количество операций:

$T = O(1) + O(n) + O(n) * (O(1) + O(1) + O(1) + O(1) + O(1)) \approx O(n)$

\section{Z-функция}

\begin{minted}[fontsize=\small, breaklines=true, linenos]{cpp}
vector<int> z_function(string s) {
    int n = (int)s.size();  // O(1)
    vector<int> z(n, 0);    // O(n)
    int l = 0, r = 0;       // O(1)
    for (int i = 1; i < n; i++) {  // O(n)
        if (i <= r)   // O(1)
            z[i] = min(r - i + 1, z[i - l]);  // O(1)
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) // O(1) в среднем
            z[i]++;  // О(1)
        if (i + z[i] - 1 > r) {  // О(1)
            r = i + z[i] - 1;    // О(1)
            l = i;   // О(1)
        }
    }
    z[0] = n;   // О(1)
    return z;   // О(1)
}
\end{minted}

Инициализация переменных в 2 и 4 строки происходит за константу.

Инициализация вектора в строке 3 работает за $O(n)$.

Цикл в строке 5 работает за $O(n)$, каждая операция внутри домножается на $O(n)$ по правилу умножения вложенных циклов.

В основном сложность алгоритма зависит от цикла в строке 8. В алгоритме мы делаем столько же действий, сколько раз сдвигается правая граница z-блока — а это $O(n)$ в сумме по всем проходам цикла. Таким образом, в среднем на каждой итерации этот цикл будет работать за какую-то константу.

Общая сложность алгоритма таким образом составит:

$T = O(1) + O(n) + O(1) + O(n) \cdot (O(1) + O(1) + O(1) + O(1) + O(1) + O(1) + O(1)) + O(1) + O(1) = O(1) + O(n) + O(n)O(1) + O(1) \approx O(n)$

\section{Алгоритм Кнута-Морриса Пратта (КМП)}

\begin{minted}[fontsize=\small, breaklines=true, linenos]{cpp}
void KMPSearch(string pat, string txt) { // pat - искомая строка, txt - текст 
	int M = pat.length();  // О(1)
	int N = txt.length();  // О(1)
	vector<int> lps(M);    // О(N)
	computeLPSArray(pat, M, lps); // О(M)
	int i = 0;   // О(1)
	int j = 0;   // О(1)
	while ((N - i) >= (M - j)) {  // O(N)
		if (pat[j] == txt[i]) { // О(1)
			j++;  // О(1)
			i++;  // О(1)
		}
		if (j == M) {  // О(1)
			cout << "Found at index " << i - j << '\n';  // О(1)
			j = lps[j - 1];  // О(1)
		}
		else if (i < N && pat[j] != txt[i]) {  // О(1)
			if (j != 0)  // О(1)
				j = lps[j - 1];  // О(1)
			else
				i = i + 1;  // О(1)
	} } }

void computeLPSArray(string pat, int M, vector<int> lps) {
	int len = 0; // О(1)
	lps[0] = 0;
	int i = 1;  // О(1)
	while (i < M) {  // О(M)
		if (pat[i] == pat[len]) {  // О(1)
			len++;  // О(1)
			lps[i] = len;  // О(1)
			i++;  // О(1)
		}
		else {
			if (len != 0)  // О(1)
				len = lps[len - 1];   // О(1)
			else {
				lps[i] = 0;  // О(1)
				i++;  // О(1)
	} } } }
\end{minted}

Инициализация переменных в строках 2-3 работает за $O(1)$.

Инициализация вектора работает за $O(N)$.

Функция $computeLPSArray$ работает за $O(M)$ (из-за цикла в строке 28).

Иницилизация переменных в строках 6-7 выполняется за константу.

Цикл в строке 8 работает за $O(N)$, все операции внутри него "--- константные.

Тогда общая временная сложность 

$T = O(1) + O(N) + O(M) + O(N)O(1) = O(N) + O(M) = O(N+M)$.

Так как $M\le N$, то можно сказать, что алгоритм работает не больше чем за 
$T = O(N+M) \approx O(2 * N) = O(N)$.

% Отобразить все источники. Даже те, на которые нет ссылок.
% \nocite{*}

% \begin{thebibliography}{99}
	\bibliographystyle{ugost2003}

% \end{thebibliography}

% Окончание основного документа и начало приложений Каждая последующая секция
% документа будет являться приложением
\appendix

\end{document}
